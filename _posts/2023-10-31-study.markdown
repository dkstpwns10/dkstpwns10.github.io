---
layout: post
title:  "[Algorithm]그리디 알고리즘"
date:   2023-11-05 06:00:00 +0900
categories: Study
---

### 그리디 알고리즘
탐욕 알고리즘(Greedy Algorithm)은 **"매순간 최적의 선택"**이라는 정의를 가지고 있다.
그러나 당장 눈 앞에 있는 최적의 선택이 전체적으로 봤을 때 "최적"의 선택인지는 알 수 없다.

거스름돈으로 예를 들자면 
동전의 단위가 10원, 6원, 1원의 단위로 존재하고 거슬러 줘야하는 돈이 12원이라고할 때

### 거스를 동전이 가장 적게 존재하는 최적의 경우는 
* 6원짜리 동전 2개

지만

### 그리디 알고리즘은 
* 10원짜리 동전 1개와 1원짜리 동전 2개

를 거슬러 주게 된다.

이렇듯 **항상 최적의 경우를 찾아내는 알고리즘이 아니기에** 사용시 유의해야한다.

그렇기에 그리디 알고리즘은 최적의 해를 찾아내는 알고리즘이 아닌 근사 값을 찾아내는 알고리즘으로 사용될 수 있다.
물론 도출된 결과가 진짜 근사 값인지에 대한 증명이 필요한 알고리즘이기도 하다.

그리디 알고리즘이 잘 작동하기 위해선 문제가 탐욕 선택 속성(greedy choice property)[^1], 최적 부분 구조(optimal substructure)[^2] 특성을 가져야한다.

그리디 알고리즘은 다음과 같은 단계를 따른다.

### 그리디 알고리즘의 단계
1. 선택 과정: 주어진 문제에 대해 최적의 선택을 한다.
2. 유효성 검사: 이 선택이 전체 문제에 대한 부분 문제의 최적해를 이루는지 확인한다.
3. 해법 구성: 유효한 선택을 만들어내는 방법을 구성한다.
4. 반복: 위 과정을 반복하여 문제 전체에 대한 해법을 구성한다.

이 단계를 대표적인 예시를 통해 코드로 구성해보자

동전이 500원, 100원, 50원, 10원으로 구성된 세상에서 거스름돈으로 1260원을 줘야할 때 그리디 알고리즘을 적용한 자바 코드이다.
주석으로 단계를 표시하였다.

~~~java
import java.util.*;

public class GreedyAlgorithmExample {
    public static void main(String[] args) {
        int[] coins = {500, 100, 50, 10}; // 동전의 종류

        int N = 1260; // 거스름돈 금액

        Map<Integer, Integer> coinCount = new HashMap<>();

        // 선택 과정: 주어진 문제에 대해 최적의 선택을 합니다.
        for (int coin : coins) {
            // 해당 동전으로 거슬러줄 수 있는 최대 개수를 구함
            int count = N / coin;
            coinCount.put(coin, count); // 해당 동전의 개수를 맵에 저장

            // 거슬러준 금액을 차감
            N -= coin * count;
        }

        // 유효성 검사: 이 선택이 전체 문제에 대한 부분 문제의 최적해를 이루는지 확인합니다.
        // (여기서는 선택이 전체적으로 최소한의 동전 개수를 사용하도록 합니다.)

        // 해법 구성: 유효한 선택을 만들어내는 방법을 구성합니다.

        // 반복: 위 과정을 반복하여 문제 전체에 대한 해법을 구성합니다.

        // 결과 출력
        for (int coin : coins) {
            int count = coinCount.get(coin);
            if (count > 0) {
                // 동전 종류와 개수 출력
                System.out.println(coin + "원: " + count + "개");
            }
        }
    }
}
~~~
이렇게 그리디 알고리즘은 간단하고 효율적이며 문제유형이 적합하다면[^1] [^2] 복잡한 문제도 쉽게 해결할 수 있다.
또한 다른 알고리즘에 비해 빠른 실행시간을 가지기 때문에 시간 복잡도가 중요한 문제에서 근사 값을 구하는데 사용될 수 있다.


[^1]: 각 단계에서 "최선의 선택"을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우. 즉, 각 단계에서 가장 이상적인 선택을 하는 것이 전체적으로 최적의 결과를 가져 옴.
[^2]: 전체 문제의 최적 해가 "부분 문제의 최적 해로 구성" 될 수 있는 경우. 즉, 전체 문제를 작은 부분 문제로 나누어 각각의 부분 문제에서 최적의 해를 구한 후 이를 조합하여 전체 문제의 최적해를 구하는 것.